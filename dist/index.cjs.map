{"version":3,"sources":["../src/server-resource.ts","../src/server-pool.ts","../src/switchboard.ts"],"names":["resource","express","call","spawn","createContext","useScope","createSignal","suspend","httpProxy"],"mappings":"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","file":"index.cjs","sourcesContent":["// src/server-resource.ts\n// Express Server as an Effection Resource\n\nimport type { Operation } from 'effection';\nimport { resource, spawn, call } from 'effection';\nimport express, { type Express, type Request, type Response } from 'express';\nimport type { Server } from 'http';\n\nexport interface ExpressServerHandle {\n  app: Express;\n  server: Server;\n  port: number;\n  hostname: string;\n}\n\n/**\n * Error thrown when a daemon server unexpectedly closes or errors.\n */\nexport class ServerDaemonError extends Error {\n  readonly hostname: string;\n  readonly port: number;\n  readonly cause?: Error;\n\n  constructor(hostname: string, port: number, cause?: Error) {\n    super(`Server \"${hostname}\" on port ${port} unexpectedly closed${cause ? `: ${cause.message}` : ''}`);\n    this.name = 'ServerDaemonError';\n    this.hostname = hostname;\n    this.port = port;\n    this.cause = cause;\n  }\n}\n\n/**\n * Creates an Express server as an Effection resource.\n * \n * The server will be automatically closed when the operation ends.\n * Uses graceful shutdown - waits for server to fully close before continuing.\n * \n * @param port - Port to listen on\n * @param hostname - Hostname for this server (used in responses)\n */\nexport function useExpressServer(\n  port: number,\n  hostname: string\n): Operation<ExpressServerHandle> {\n  return resource<ExpressServerHandle>(function* (provide) {\n    const app: Express = express();\n    \n    // Disable x-powered-by header\n    app.disable('x-powered-by');\n    \n    // Health check endpoint\n    app.get('/health', (_req: Request, res: Response) => {\n      res.json({\n        status: 'ok',\n        hostname,\n        port,\n        uptime: process.uptime(),\n      });\n    });\n    \n    // Default route - shows which backend handled the request\n    app.use((req: Request, res: Response) => {\n      res.json({\n        message: `Hello from ${hostname}!`,\n        backend: {\n          hostname,\n          port,\n        },\n        request: {\n          method: req.method,\n          path: req.path,\n          headers: {\n            host: req.get('host'),\n            'x-forwarded-for': req.get('x-forwarded-for'),\n          },\n        },\n        timestamp: new Date().toISOString(),\n      });\n    });\n    \n    // Create server and wait for it to be listening\n    const server: Server = yield* call(() => new Promise<Server>((resolve, reject) => {\n      const srv = app.listen(port, () => {\n        console.log(`[${hostname}] Server started on port ${port}`);\n        resolve(srv);\n      });\n      srv.on('error', reject);\n    }));\n    \n    try {\n      // Provide the server handle to the caller\n      yield* provide({ app, server, port, hostname });\n    } finally {\n      // Graceful shutdown - wait for server to fully close (lspx pattern)\n      console.log(`[${hostname}] Closing server on port ${port}...`);\n      server.close();\n      yield* call(() => new Promise<void>((resolve) => {\n        server.on('close', resolve);\n      }));\n      console.log(`[${hostname}] Server closed`);\n    }\n  });\n}\n\n/**\n * Creates an Express server daemon - like useExpressServer but throws if\n * the server unexpectedly closes or errors.\n * \n * This follows the lspx useDaemon pattern: a background task watches the\n * server and throws ServerDaemonError if it dies unexpectedly.\n * \n * @param port - Port to listen on\n * @param hostname - Hostname for this server (used in responses)\n */\nexport function* useExpressServerDaemon(\n  port: number,\n  hostname: string\n): Operation<ExpressServerHandle> {\n  const handle = yield* useExpressServer(port, hostname);\n  \n  // Spawn a watcher that throws if server unexpectedly closes (lspx pattern)\n  yield* spawn(function* () {\n    // Wait for close or error event\n    const error = yield* call(() => new Promise<Error | undefined>((resolve) => {\n      handle.server.on('close', () => resolve(undefined));\n      handle.server.on('error', (err) => resolve(err));\n    }));\n    \n    // If we get here, the server closed unexpectedly\n    throw new ServerDaemonError(hostname, port, error);\n  });\n  \n  return handle;\n}\n","// src/server-pool.ts\n// Server Pool - manages dynamic Express server instances\n// Refactored to use lspx patterns: signals for events, clean async API\n\nimport type { Operation, Task, Context, Scope } from 'effection';\nimport { resource, createContext, useScope, suspend, createSignal, call } from 'effection';\nimport type { ServerInfo, ServerPool, ServerEvent } from './types';\nimport { useExpressServerDaemon } from './server-resource';\n\n/**\n * Context for accessing the server pool from any operation\n */\nexport const ServerPoolContext: Context<ServerPool> = createContext<ServerPool>('server-pool');\n\n/**\n * Configuration for the server pool\n */\nexport interface ServerPoolConfig {\n  /** Starting port for dynamic servers */\n  basePort: number;\n  /** Maximum number of servers to spawn */\n  maxServers?: number;\n}\n\n/**\n * Creates a server pool resource that manages dynamic Express servers.\n * \n * Refactored with lspx patterns:\n * - Signal-based events for observability (subscribe to pool.events)\n * - Clean Promise-based getOrCreate API (no Operation wrapper needed)\n * - Channel-based spawn worker for clean async bridging\n * - Daemon pattern for server health monitoring\n * \n * The pool:\n * - Tracks servers by hostname\n * - Assigns ports dynamically starting from basePort\n * - Spawns new servers as child tasks (so they auto-cleanup)\n * - Emits events when servers start/stop/error\n * - Cleans up all servers when the pool is shut down\n */\nexport function useServerPool(config: ServerPoolConfig): Operation<ServerPool> {\n  return resource<ServerPool>(function* (provide) {\n    const { basePort, maxServers = 100 } = config;\n    \n    // Map of hostname -> server info\n    const servers = new Map<string, ServerInfo>();\n    \n    // Map of hostname -> spawn task\n    const serverTasks = new Map<string, Task<void>>();\n    \n    // Pending creation promises to avoid race conditions\n    const pendingCreations = new Map<string, Promise<ServerInfo>>();\n    \n    // Next available port\n    let nextPort = basePort;\n    \n    // Capture scope for spawning servers from callbacks\n    const scope: Scope = yield* useScope();\n    \n    // === Signal for server events (lspx pattern) ===\n    // Signals can be sent from anywhere (callbacks, generators, async)\n    const events = createSignal<ServerEvent, void>();\n    \n    /**\n     * Emit a server event to all subscribers\n     */\n    function emitEvent(event: ServerEvent): void {\n      events.send(event);\n    }\n    \n    /**\n     * Actually spawn a server - called from within Effection context.\n     * This is the core spawning logic, extracted for clarity.\n     */\n    function* doSpawnServer(hostname: string, port: number): Operation<ServerInfo> {\n      // Create placeholder info\n      const info: ServerInfo = {\n        hostname,\n        port,\n        app: null as any,\n        server: null as any,\n        task: null as any,\n        startedAt: new Date(),\n      };\n      \n      // Store immediately so concurrent requests see it\n      servers.set(hostname, info);\n      \n      // Create a promise that resolves when the server is ready\n      let resolveReady: (info: ServerInfo) => void;\n      let rejectReady: (err: Error) => void;\n      const readyPromise = new Promise<ServerInfo>((resolve, reject) => {\n        resolveReady = resolve;\n        rejectReady = reject;\n      });\n      \n      // Start the server as a long-lived task using scope.run()\n      // The task suspends and stays alive until halted\n      const task = scope.run(function* (): Operation<void> {\n        try {\n          // Use daemon pattern - throws if server unexpectedly closes\n          const handle = yield* useExpressServerDaemon(port, hostname);\n          \n          // Update the server info with real values\n          info.app = handle.app;\n          info.server = handle.server;\n          \n          // Emit started event\n          emitEvent({ type: 'started', hostname, port });\n          \n          // Signal that we're ready\n          resolveReady!(info);\n          \n          // Keep running until halted\n          yield* suspend();\n        } catch (error) {\n          // Emit error event\n          emitEvent({ \n            type: 'error', \n            hostname, \n            error: error as Error,\n            message: (error as Error).message \n          });\n          rejectReady!(error as Error);\n          throw error;\n        } finally {\n          // Cleanup when halted\n          emitEvent({ type: 'stopped', hostname });\n          servers.delete(hostname);\n          serverTasks.delete(hostname);\n        }\n      });\n      \n      // Store task reference\n      info.task = task;\n      serverTasks.set(hostname, task);\n      \n      // Wait for the server to be ready and return\n      // Use call() to convert Promise to Operation\n      return yield* call(() => readyPromise);\n    }\n    \n    /**\n     * Get or create a server - Promise-based API for use anywhere.\n     * \n     * This is the primary API - clean, simple, no Operation wrapper.\n     * Handles:\n     * - Fast path for existing servers\n     * - Deduplication of concurrent requests for same hostname\n     * - Spawning via scope.run() for proper lifecycle management\n     */\n    async function getOrCreate(hostname: string): Promise<ServerInfo> {\n      // Fast path: server already exists and is ready\n      const existing = servers.get(hostname);\n      if (existing && existing.server) {\n        return existing;\n      }\n      \n      // Check if there's already a pending creation (deduplication)\n      const pending = pendingCreations.get(hostname);\n      if (pending) {\n        return pending;\n      }\n      \n      // Check max servers limit\n      if (servers.size >= maxServers) {\n        const error = new Error(`Maximum number of servers (${maxServers}) reached`);\n        emitEvent({ type: 'error', hostname, error, message: error.message });\n        throw error;\n      }\n      \n      // Assign a port\n      const port = nextPort++;\n      \n      console.log(`[Pool] Creating server for \"${hostname}\" on port ${port}`);\n      \n      // Create the spawn promise\n      const spawnPromise = scope.run(function* (): Operation<ServerInfo> {\n        return yield* doSpawnServer(hostname, port);\n      });\n      \n      // Store to deduplicate concurrent requests\n      pendingCreations.set(hostname, spawnPromise);\n      \n      try {\n        return await spawnPromise;\n      } finally {\n        pendingCreations.delete(hostname);\n      }\n    }\n    \n    /**\n     * Get server info if it exists (sync)\n     */\n    function get(hostname: string): ServerInfo | undefined {\n      return servers.get(hostname);\n    }\n    \n    /**\n     * List all running servers (sync)\n     */\n    function list(): ServerInfo[] {\n      return Array.from(servers.values()).filter(s => s.server !== null);\n    }\n    \n    /**\n     * Shutdown a specific server\n     */\n    async function shutdown(hostname: string): Promise<void> {\n      const task = serverTasks.get(hostname);\n      if (task) {\n        console.log(`[Pool] Requesting shutdown for \"${hostname}\"`);\n        await task.halt();\n      }\n    }\n    \n    // Create the pool interface\n    const pool: ServerPool = {\n      getOrCreate,\n      get,\n      list,\n      shutdown,\n      events,  // Expose the event stream for subscribers\n    };\n    \n    // Set the context so children can access the pool\n    yield* ServerPoolContext.set(pool);\n    \n    console.log(`[Pool] Server pool ready (base port: ${basePort})`);\n    \n    try {\n      yield* provide(pool);\n    } finally {\n      console.log(`[Pool] Shutting down all servers...`);\n      console.log(`[Pool] ${servers.size} server(s) will be cleaned up`);\n      // Close the event signal\n      events.close(undefined as void);\n    }\n  });\n}\n","// src/switchboard.ts\n// The Switchboard - HTTP proxy that routes to dynamic backends\n\nimport type { Operation } from 'effection';\nimport { resource, call } from 'effection';\nimport express, { type Express, type Request, type Response, type NextFunction } from 'express';\nimport httpProxy from 'http-proxy';\nimport type { Server } from 'http';\nimport type { SwitchboardConfig, ServerInfo, ServerPool } from './types';\n\nexport interface SwitchboardHandle {\n  app: Express;\n  server: Server;\n  port: number;\n}\n\n/**\n * Extracts the app hostname from the request.\n * \n * Supports formats:\n * - app-name.localhost -> app-name\n * - app-name.localhost:8000 -> app-name\n * - localhost (returns defaultHostname or 'default')\n */\nfunction extractHostname(req: Request, defaultHostname: string): string {\n  const host = req.get('host') || '';\n  const hostWithoutPort = host.split(':')[0];\n  \n  // Handle patterns like \"app-a.localhost\" -> \"app-a\"\n  if (hostWithoutPort.includes('.')) {\n    const parts = hostWithoutPort.split('.');\n    // Take the first part as the app name\n    return parts[0];\n  }\n  \n  // Check for X-App-Name header as alternative\n  const appHeader = req.get('x-app-name');\n  if (appHeader) {\n    return appHeader;\n  }\n  \n  // Default\n  return defaultHostname;\n}\n\n/**\n * Creates the switchboard proxy resource.\n * \n * The switchboard:\n * - Listens on the main port\n * - Extracts hostname from requests\n * - Creates backend servers on demand via the pool\n * - Proxies requests to the appropriate backend\n */\nexport function useSwitchboard(\n  config: SwitchboardConfig,\n  pool: ServerPool\n): Operation<SwitchboardHandle> {\n  return resource<SwitchboardHandle>(function* (provide) {\n    const { port, defaultHostname = 'default' } = config;\n    \n    const app: Express = express();\n    \n    // Create the proxy server\n    const proxy = httpProxy.createProxyServer({\n      // Don't change the host header\n      changeOrigin: false,\n      // WebSocket support\n      ws: true,\n    });\n    \n    // Handle proxy errors\n    proxy.on('error', (err, _req, res) => {\n      console.error(`[Switchboard] Proxy error:`, err.message);\n      if (res && 'writeHead' in res && !res.headersSent) {\n        (res as Response).status(502).json({\n          error: 'Bad Gateway',\n          message: err.message,\n        });\n      }\n    });\n    \n    // Log proxied requests\n    proxy.on('proxyReq', (_proxyReq, req, _res) => {\n      const hostname = extractHostname(req as Request, defaultHostname);\n      console.log(`[Switchboard] Proxying ${req.method} ${req.url} -> ${hostname}`);\n    });\n    \n    app.disable('x-powered-by');\n    \n    // Health check for the switchboard itself\n    app.get('/__switchboard/health', (_req: Request, res: Response) => {\n      res.json({\n        status: 'ok',\n        servers: pool.list().map(s => ({\n          hostname: s.hostname,\n          port: s.port,\n          uptime: Date.now() - s.startedAt.getTime(),\n        })),\n      });\n    });\n    \n    // List all running servers\n    app.get('/__switchboard/servers', (_req: Request, res: Response) => {\n      res.json({\n        servers: pool.list().map(s => ({\n          hostname: s.hostname,\n          port: s.port,\n          startedAt: s.startedAt.toISOString(),\n        })),\n      });\n    });\n    \n    // Main proxy handler\n    app.use(async (req: Request, res: Response, next: NextFunction) => {\n      try {\n        // Extract the target hostname\n        const hostname = extractHostname(req, defaultHostname);\n        \n        console.log(`[Switchboard] Request for hostname: \"${hostname}\"`);\n        \n        // Get or create the backend server (now using clean Promise API)\n        const serverInfo: ServerInfo = await pool.getOrCreate(hostname);\n        \n        // Proxy the request to the backend\n        const target = `http://localhost:${serverInfo.port}`;\n        \n        proxy.web(req, res, { target }, (err) => {\n          if (err) {\n            console.error(`[Switchboard] Proxy failed:`, err.message);\n            if (!res.headersSent) {\n              res.status(502).json({\n                error: 'Bad Gateway',\n                message: `Failed to proxy to ${hostname}: ${err.message}`,\n              });\n            }\n          }\n        });\n      } catch (error) {\n        console.error(`[Switchboard] Error:`, error);\n        next(error);\n      }\n    });\n    \n    // Error handler\n    app.use((err: Error, _req: Request, res: Response, _next: NextFunction) => {\n      console.error(`[Switchboard] Unhandled error:`, err);\n      if (!res.headersSent) {\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: err.message,\n        });\n      }\n    });\n    \n    // Start listening and wait for it to be ready\n    const server: Server = yield* call(() => new Promise<Server>((resolve, reject) => {\n      const srv = app.listen(port, () => {\n        console.log(`[Switchboard] Listening on port ${port}`);\n        console.log(`[Switchboard] Try: curl -H \"Host: myapp.localhost\" http://localhost:${port}/`);\n        resolve(srv);\n      });\n      srv.on('error', reject);\n    }));\n    \n    // Handle WebSocket upgrades\n    server.on('upgrade', async (req, socket, head) => {\n      try {\n        const hostname = extractHostname(req as unknown as Request, defaultHostname);\n        const serverInfo = await pool.getOrCreate(hostname);\n        const target = `http://localhost:${serverInfo.port}`;\n        \n        proxy.ws(req, socket, head, { target });\n      } catch (error) {\n        console.error(`[Switchboard] WebSocket upgrade failed:`, error);\n        socket.destroy();\n      }\n    });\n    \n    try {\n      yield* provide({ app, server, port });\n    } finally {\n      // Graceful shutdown - wait for server to close (lspx pattern)\n      console.log(`[Switchboard] Closing proxy server...`);\n      proxy.close();\n      server.close();\n      yield* call(() => new Promise<void>((resolve) => {\n        server.on('close', resolve);\n      }));\n      console.log(`[Switchboard] Proxy server closed`);\n    }\n  });\n}\n"]}